# X402 WebåŸç”Ÿæ”¯ä»˜æ ‡å‡†å¼€å‘è®¡åˆ’

## ğŸ“‹ åè®®æ¦‚è¿°

X402 æ˜¯ä¸€ä¸ª Web åŸç”Ÿæ”¯ä»˜æ ‡å‡†ï¼Œåˆ©ç”¨ HTTP çš„ "402 Payment Required" çŠ¶æ€ç ï¼Œå°†åŠ å¯†è´§å¸æ”¯ä»˜ç›´æ¥é›†æˆåˆ° HTTP æµç¨‹ä¸­ã€‚è¯¥åè®®è§£è€¦äº†åŒºå—é“¾å’Œä»£å¸ï¼Œä»»ä½•ç¬¦åˆåè®®è¦æ±‚çš„é“¾æˆ–ä»£å¸éƒ½å¯ä»¥ä½¿ç”¨ã€‚

### æ ¸å¿ƒç‰¹æ€§
- **Web åŸç”Ÿé›†æˆ**ï¼šåˆ©ç”¨ HTTP çŠ¶æ€ç å’Œå¤´éƒ¨ï¼Œæ— ç¼é›†æˆåˆ°ç°æœ‰ Web æ¶æ„
- **é“¾å’Œä»£å¸æ— å…³**ï¼šæ”¯æŒå¤šé“¾ï¼ˆEVMã€Solanaã€Suiç­‰ï¼‰å’Œå¤šç§ä»£å¸
- **å¾®æ”¯ä»˜å‹å¥½**ï¼šç»“åˆç¨³å®šå¸å’Œå¿«é€Ÿç»“ç®—ï¼Œä½¿æŒ‰æ¬¡ä»˜è´¹å˜å¾—å¯è¡Œ
- **æœºå™¨å¯¹æœºå™¨æ”¯ä»˜**ï¼šä¸“ä¸º AI Agentsã€IoT è®¾å¤‡ç­‰è‡ªä¸»ä»£ç†è®¾è®¡
- **æ— è´¦æˆ·ä¾èµ–**ï¼šæ— éœ€æ³¨å†Œè´¦æˆ·æˆ–ä¿¡ç”¨å¡ï¼Œè®¿é—®æ—¶ç›´æ¥æ”¯ä»˜

### ä¸»è¦åº”ç”¨åœºæ™¯
- API è®¿é—®ä»˜è´¹
- AI Agentsï¼ˆAgentFiï¼‰
- æœºå™¨å¯¹æœºå™¨æ”¯ä»˜ï¼ˆMachineFiï¼‰
- å¾®æ”¯ä»˜å’ŒæŒ‰ä½¿ç”¨ä»˜è´¹
- å†…å®¹ä»˜è´¹è®¿é—®
- æœåŠ¡è®¢é˜…

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

### çŸ­æœŸç›®æ ‡ (3ä¸ªæœˆ)
- [ ] å®ç° X402 åè®®æ ¸å¿ƒç»„ä»¶
- [ ] å¼€å‘ Facilitator æœåŠ¡
- [ ] åˆ›å»ºå®¢æˆ·ç«¯ SDK
- [ ] å»ºç«‹æµ‹è¯•å’ŒéªŒè¯ä½“ç³»

### ä¸­æœŸç›®æ ‡ (6ä¸ªæœˆ)
- [ ] é›†æˆå¤šé“¾æ”¯æŒ
- [ ] å¼€å‘é«˜çº§æ”¯ä»˜åŠŸèƒ½
- [ ] å»ºç«‹ç”Ÿæ€ç³»ç»Ÿ
- [ ] å®ç°ç”Ÿäº§çº§éƒ¨ç½²

### é•¿æœŸç›®æ ‡ (12ä¸ªæœˆ)
- [ ] æ‰©å±• AI Agent é›†æˆ
- [ ] å¼€å‘ä¼ä¸šçº§è§£å†³æ–¹æ¡ˆ
- [ ] å»ºç«‹æ ‡å‡†åŒ–ç»„ç»‡
- [ ] å®ç°å¤§è§„æ¨¡é‡‡ç”¨

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client        â”‚    â”‚   Resource      â”‚    â”‚   Facilitator   â”‚
â”‚   (å®¢æˆ·ç«¯)       â”‚â—„â”€â”€â–ºâ”‚   Server        â”‚â—„â”€â”€â–ºâ”‚   (æ”¯ä»˜å¤„ç†)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Blockchain    â”‚
                    â”‚   (åŒºå—é“¾ç½‘ç»œ)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### åè®®æµç¨‹

1. **å®¢æˆ·ç«¯è¯·æ±‚** â†’ èµ„æºæœåŠ¡å™¨å‘é€ HTTP è¯·æ±‚
2. **æ”¯ä»˜è¦æ±‚** â†’ æœåŠ¡å™¨è¿”å› 402 Payment Required + PaymentRequired JSON
3. **æ”¯ä»˜æ„å»º** â†’ å®¢æˆ·ç«¯æ„å»ºæ”¯ä»˜è´Ÿè½½ï¼ˆPayment Payloadï¼‰
4. **æ”¯ä»˜æäº¤** â†’ é‡è¯•è¯·æ±‚ï¼Œåœ¨ X-PAYMENT å¤´ä¸­é™„ä¸Šæ”¯ä»˜è´Ÿè½½
5. **æ”¯ä»˜éªŒè¯** â†’ æœåŠ¡å™¨éªŒè¯æ”¯ä»˜ï¼ˆæœ¬åœ°æˆ–é€šè¿‡ Facilitatorï¼‰
6. **ç»“ç®—æ‰§è¡Œ** â†’ è§¦å‘é“¾ä¸Šç»“ç®—
7. **ç¡®è®¤è¿”å›** â†’ è¿”å› 200 OK + æ”¯ä»˜ä¿¡æ¯

### æŠ€æœ¯æ ˆ

**æœåŠ¡ç«¯**
- Node.js + TypeScript
- Express.js / Fastify
- å¤šé“¾ SDKï¼ˆethers.jsã€@solana/web3.jsã€@mysten/sui.jsï¼‰
- Redisï¼ˆç¼“å­˜å’Œä¼šè¯ï¼‰

**å®¢æˆ·ç«¯ SDK**
- TypeScript/JavaScript
- Python
- Go
- Rust

**Facilitator æœåŠ¡**
- Node.js + TypeScript
- å¤šé“¾æ”¯ä»˜å¤„ç†
- æ”¯ä»˜éªŒè¯å’Œç»“ç®—
- ç›‘æ§å’Œåˆ†æ

## ğŸ“… å¼€å‘é˜¶æ®µè§„åˆ’

### é˜¶æ®µ 1: æ ¸å¿ƒåè®®å®ç° (ç¬¬1-4å‘¨)

#### ç¬¬1å‘¨: åè®®æ ¸å¿ƒç»„ä»¶å¼€å‘
**ç›®æ ‡**: å®ç° X402 åè®®çš„åŸºç¡€æ¶æ„

**ä»»åŠ¡æ¸…å•**:
- [ ] è®¾è®¡ PaymentRequired JSON ç»“æ„
- [ ] å®ç° Payment Payload æ ¼å¼
- [ ] å¼€å‘ HTTP ä¸­é—´ä»¶
- [ ] åˆ›å»ºåŸºç¡€éªŒè¯é€»è¾‘

**æ ¸å¿ƒæ•°æ®ç»“æ„**:
```typescript
// PaymentRequired JSON ç»“æ„
interface PaymentRequired {
  // æ”¯ä»˜æ–¹æ¡ˆæ ‡è¯†ç¬¦
  scheme: string;
  
  // æ”¯ä»˜ç½‘ç»œä¿¡æ¯
  network: {
    chainId: string;
    name: string;
    type: 'evm' | 'solana' | 'sui' | 'other';
  };
  
  // æ”¯ä»˜è¦æ±‚
  payment: {
    amount: string;
    token: {
      address: string;
      symbol: string;
      decimals: number;
    };
    recipient: string;
    deadline?: number; // Unix æ—¶é—´æˆ³
  };
  
  // Facilitator ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰
  facilitator?: {
    verifyUrl: string;
    settleUrl: string;
  };
  
  // å…ƒæ•°æ®
  metadata?: {
    resource: string;
    description?: string;
    nonce?: string;
  };
}

// Payment Payload ç»“æ„
interface PaymentPayload {
  // æ”¯ä»˜ä¿¡æ¯
  scheme: string;
  network: {
    chainId: string;
    type: 'evm' | 'solana' | 'sui' | 'other';
  };
  
  // äº¤æ˜“è¯¦æƒ…
  transaction: {
    amount: string;
    token: {
      address: string;
      symbol: string;
      decimals: number;
    };
    recipient: string;
    sender: string;
    nonce: string;
    deadline?: number;
  };
  
  // ç­¾åä¿¡æ¯
  signature: {
    type: 'ecdsa' | 'ed25519' | 'bip322';
    data: string;
    publicKey?: string;
  };
  
  // æ—¶é—´æˆ³
  timestamp: number;
}
```

**HTTP ä¸­é—´ä»¶å®ç°**:
```typescript
// X402 ä¸­é—´ä»¶
import { Request, Response, NextFunction } from 'express';
import { PaymentValidator } from './PaymentValidator';
import { FacilitatorClient } from './FacilitatorClient';

export interface X402Config {
  paymentRequired: PaymentRequired;
  facilitator?: {
    verifyUrl: string;
    settleUrl: string;
  };
  validateLocally?: boolean;
}

export class X402Middleware {
  private validator: PaymentValidator;
  private facilitatorClient?: FacilitatorClient;

  constructor(private config: X402Config) {
    this.validator = new PaymentValidator();
    
    if (config.facilitator) {
      this.facilitatorClient = new FacilitatorClient(config.facilitator);
    }
  }

  // ä¸»è¦ä¸­é—´ä»¶å‡½æ•°
  middleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        // æ£€æŸ¥æ˜¯å¦æœ‰æ”¯ä»˜å¤´éƒ¨
        const paymentHeader = req.headers['x-payment'];
        
        if (!paymentHeader) {
          // é¦–æ¬¡è¯·æ±‚ï¼Œè¿”å›æ”¯ä»˜è¦æ±‚
          return this.sendPaymentRequired(res);
        }

        // éªŒè¯æ”¯ä»˜
        const isValid = await this.validatePayment(paymentHeader as string);
        
        if (!isValid) {
          // æ”¯ä»˜æ— æ•ˆï¼Œè¿”å›æ›´æ–°åçš„æ”¯ä»˜è¦æ±‚
          return this.sendPaymentRequired(res, 'Payment validation failed');
        }

        // æ”¯ä»˜æœ‰æ•ˆï¼Œæ‰§è¡Œç»“ç®—
        const settlementResult = await this.settlePayment(paymentHeader as string);
        
        if (!settlementResult.success) {
          return this.sendPaymentRequired(res, 'Settlement failed');
        }

        // æ”¯ä»˜æˆåŠŸï¼Œæ·»åŠ ç»“ç®—ä¿¡æ¯åˆ°å“åº”å¤´
        res.setHeader('X-PAYMENT-RESPONSE', JSON.stringify(settlementResult.data));
        
        // ç»§ç»­å¤„ç†è¯·æ±‚
        next();
      } catch (error) {
        console.error('X402 middleware error:', error);
        return this.sendPaymentRequired(res, 'Internal server error');
      }
    };
  }

  // å‘é€æ”¯ä»˜è¦æ±‚å“åº”
  private sendPaymentRequired(res: Response, reason?: string) {
    const paymentRequired: PaymentRequired = {
      ...this.config.paymentRequired,
      metadata: {
        ...this.config.paymentRequired.metadata,
        nonce: this.generateNonce(),
        ...(reason && { error: reason }),
      },
    };

    res.status(402).json(paymentRequired);
  }

  // éªŒè¯æ”¯ä»˜
  private async validatePayment(paymentHeader: string): Promise<boolean> {
    try {
      // è§£ç æ”¯ä»˜è´Ÿè½½
      const paymentPayload: PaymentPayload = JSON.parse(
        Buffer.from(paymentHeader, 'base64').toString()
      );

      // æœ¬åœ°éªŒè¯
      if (this.config.validateLocally) {
        return this.validator.validate(paymentPayload);
      }

      // é€šè¿‡ Facilitator éªŒè¯
      if (this.facilitatorClient) {
        return await this.facilitatorClient.verifyPayment(paymentPayload);
      }

      return false;
    } catch (error) {
      console.error('Payment validation error:', error);
      return false;
    }
  }

  // ç»“ç®—æ”¯ä»˜
  private async settlePayment(paymentHeader: string): Promise<{
    success: boolean;
    data?: any;
    error?: string;
  }> {
    try {
      const paymentPayload: PaymentPayload = JSON.parse(
        Buffer.from(paymentHeader, 'base64').toString()
      );

      if (this.facilitatorClient) {
        return await this.facilitatorClient.settlePayment(paymentPayload);
      }

      // æœ¬åœ°ç»“ç®—é€»è¾‘ï¼ˆç®€åŒ–å®ç°ï¼‰
      return {
        success: true,
        data: {
          transactionHash: '0x...',
          network: paymentPayload.network.chainId,
          confirmedAt: Date.now(),
        },
      };
    } catch (error) {
      console.error('Payment settlement error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  // ç”Ÿæˆéšæœºæ•°
  private generateNonce(): string {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }
}
```

**äº¤ä»˜ç‰©**:
- X402 åè®®æ ¸å¿ƒç»„ä»¶
- HTTP ä¸­é—´ä»¶
- æ•°æ®ç»“æ„å®šä¹‰
- åŸºç¡€éªŒè¯é€»è¾‘

#### ç¬¬2å‘¨: Facilitator æœåŠ¡å¼€å‘
**ç›®æ ‡**: å®ç°æ”¯ä»˜éªŒè¯å’Œç»“ç®—æœåŠ¡

**ä»»åŠ¡æ¸…å•**:
- [ ] è®¾è®¡ Facilitator API æ¥å£
- [ ] å®ç°æ”¯ä»˜éªŒè¯é€»è¾‘
- [ ] å¼€å‘å¤šé“¾ç»“ç®—åŠŸèƒ½
- [ ] åˆ›å»ºç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**Facilitator æœåŠ¡å®ç°**:
```typescript
// Facilitator ä¸»æœåŠ¡
import express from 'express';
import { PaymentVerifier } from './PaymentVerifier';
import { SettlementService } from './SettlementService';
import { MultiChainProvider } from './MultiChainProvider';

export class FacilitatorServer {
  private app: express.Application;
  private paymentVerifier: PaymentVerifier;
  private settlementService: SettlementService;
  private chainProvider: MultiChainProvider;

  constructor() {
    this.app = express();
    this.paymentVerifier = new PaymentVerifier();
    this.settlementService = new SettlementService();
    this.chainProvider = new MultiChainProvider();
    
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMiddleware(): void {
    this.app.use(express.json());
    this.app.use((req, res, next) => {
      console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
      next();
    });
  }

  private setupRoutes(): void {
    // æ”¯ä»˜éªŒè¯æ¥å£
    this.app.post('/verify', async (req, res) => {
      try {
        const paymentPayload: PaymentPayload = req.body;
        
        const isValid = await this.paymentVerifier.verify(paymentPayload);
        
        res.json({
          valid: isValid,
          timestamp: Date.now(),
        });
      } catch (error) {
        console.error('Verification error:', error);
        res.status(400).json({
          valid: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    });

    // æ”¯ä»˜ç»“ç®—æ¥å£
    this.app.post('/settle', async (req, res) => {
      try {
        const paymentPayload: PaymentPayload = req.body;
        
        const settlementResult = await this.settlementService.settle(paymentPayload);
        
        res.json({
          success: true,
          data: settlementResult,
          timestamp: Date.now(),
        });
      } catch (error) {
        console.error('Settlement error:', error);
        res.status(400).json({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    });

    // æ”¯ä»˜çŠ¶æ€æŸ¥è¯¢æ¥å£
    this.app.get('/status/:transactionHash', async (req, res) => {
      try {
        const { transactionHash } = req.params;
        const { network } = req.query;
        
        const status = await this.chainProvider.getTransactionStatus(
          transactionHash,
          network as string
        );
        
        res.json({
          hash: transactionHash,
          network,
          status,
          timestamp: Date.now(),
        });
      } catch (error) {
        console.error('Status query error:', error);
        res.status(400).json({
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    });

    // å¥åº·æ£€æŸ¥æ¥å£
    this.app.get('/health', (req, res) => {
      res.json({
        status: 'healthy',
        timestamp: Date.now(),
        version: process.env.VERSION || '1.0.0',
      });
    });
  }

  // å¯åŠ¨æœåŠ¡
  public start(port: number = 3000): void {
    this.app.listen(port, () => {
      console.log(`Facilitator server running on port ${port}`);
    });
  }
}

// æ”¯ä»˜éªŒè¯å™¨
export class PaymentVerifier {
  async verify(paymentPayload: PaymentPayload): Promise<boolean> {
    try {
      // 1. éªŒè¯åŸºæœ¬æ ¼å¼
      if (!this.validateFormat(paymentPayload)) {
        return false;
      }

      // 2. éªŒè¯æ—¶é—´æˆ³å’Œæˆªæ­¢æ—¶é—´
      if (!this.validateTimestamp(paymentPayload)) {
        return false;
      }

      // 3. éªŒè¯ç­¾å
      if (!await this.validateSignature(paymentPayload)) {
        return false;
      }

      // 4. éªŒè¯é‡‘é¢å’Œä»£å¸
      if (!this.validatePaymentDetails(paymentPayload)) {
        return false;
      }

      return true;
    } catch (error) {
      console.error('Payment verification error:', error);
      return false;
    }
  }

  private validateFormat(payment: PaymentPayload): boolean {
    return !!(
      payment.scheme &&
      payment.network &&
      payment.transaction &&
      payment.signature &&
      payment.timestamp
    );
  }

  private validateTimestamp(payment: PaymentPayload): boolean {
    const now = Date.now();
    const paymentTime = payment.timestamp;
    
    // æ£€æŸ¥æ—¶é—´æˆ³æ˜¯å¦åœ¨åˆç†èŒƒå›´å†…ï¼ˆ5åˆ†é’Ÿï¼‰
    if (Math.abs(now - paymentTime) > 5 * 60 * 1000) {
      return false;
    }

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æˆªæ­¢æ—¶é—´
    if (payment.transaction.deadline && now > payment.transaction.deadline) {
      return false;
    }

    return true;
  }

  private async validateSignature(payment: PaymentPayload): Promise<boolean> {
    try {
      const message = this.createSignatureMessage(payment);
      const { signature, publicKey } = payment.signature;

      switch (payment.signature.type) {
        case 'ecdsa':
          return this.verifyECDSASignature(message, signature, publicKey);
        case 'ed25519':
          return this.verifyEd25519Signature(message, signature, publicKey);
        case 'bip322':
          return this.verifyBIP322Signature(message, signature, payment.transaction.sender);
        default:
          return false;
      }
    } catch (error) {
      console.error('Signature validation error:', error);
      return false;
    }
  }

  private createSignatureMessage(payment: PaymentPayload): string {
    const messageData = {
      scheme: payment.scheme,
      network: payment.network,
      transaction: {
        amount: payment.transaction.amount,
        token: payment.transaction.token,
        recipient: payment.transaction.recipient,
        sender: payment.transaction.sender,
        nonce: payment.transaction.nonce,
        deadline: payment.transaction.deadline,
      },
      timestamp: payment.timestamp,
    };

    return JSON.stringify(messageData, Object.keys(messageData).sort());
  }

  private validatePaymentDetails(payment: PaymentPayload): boolean {
    const { transaction } = payment;
    
    // éªŒè¯é‡‘é¢æ ¼å¼
    if (!transaction.amount || isNaN(Number(transaction.amount))) {
      return false;
    }

    // éªŒè¯ä»£å¸åœ°å€
    if (!transaction.token.address || !transaction.token.symbol) {
      return false;
    }

    // éªŒè¯æ”¶æ¬¾åœ°å€
    if (!transaction.recipient) {
      return false;
    }

    return true;
  }

  // ç­¾åéªŒè¯æ–¹æ³•ï¼ˆç®€åŒ–å®ç°ï¼‰
  private verifyECDSASignature(message: string, signature: string, publicKey?: string): boolean {
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨é€‚å½“çš„åŠ å¯†åº“
    return true; // å ä½ç¬¦
  }

  private verifyEd25519Signature(message: string, signature: string, publicKey?: string): boolean {
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨é€‚å½“çš„åŠ å¯†åº“
    return true; // å ä½ç¬¦
  }

  private verifyBIP322Signature(message: string, signature: string, address: string): boolean {
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨é€‚å½“çš„åŠ å¯†åº“
    return true; // å ä½ç¬¦
  }
}

// ç»“ç®—æœåŠ¡
export class SettlementService {
  private chainProvider: MultiChainProvider;

  constructor() {
    this.chainProvider = new MultiChainProvider();
  }

  async settle(paymentPayload: PaymentPayload): Promise<any> {
    try {
      const { network, transaction } = paymentPayload;

      // æ ¹æ®ç½‘ç»œç±»å‹é€‰æ‹©ç»“ç®—æ–¹æ³•
      switch (network.type) {
        case 'evm':
          return await this.settleEVMPayment(network, transaction);
        case 'solana':
          return await this.settleSolanaPayment(network, transaction);
        case 'sui':
          return await this.settleSuiPayment(network, transaction);
        default:
          throw new Error(`Unsupported network type: ${network.type}`);
      }
    } catch (error) {
      console.error('Settlement error:', error);
      throw error;
    }
  }

  private async settleEVMPayment(network: any, transaction: any): Promise<any> {
    // EVM é“¾ç»“ç®—é€»è¾‘
    const provider = this.chainProvider.getEVMProvider(network.chainId);
    
    // æ„å»ºäº¤æ˜“
    const tx = {
      to: transaction.recipient,
      value: this.parseAmount(transaction.amount, transaction.token.decimals),
      data: '0x', // ç®€å•è½¬è´¦
    };

    // å‘é€äº¤æ˜“
    const txHash = await provider.sendTransaction(tx);
    
    // ç­‰å¾…ç¡®è®¤
    const receipt = await provider.waitForTransaction(txHash);

    return {
      transactionHash: txHash,
      blockNumber: receipt.blockNumber,
      network: network.chainId,
      confirmedAt: Date.now(),
      gasUsed: receipt.gasUsed.toString(),
    };
  }

  private async settleSolanaPayment(network: any, transaction: any): Promise<any> {
    // Solana é“¾ç»“ç®—é€»è¾‘
    const connection = this.chainProvider.getSolanaConnection(network.chainId);
    
    // æ„å»ºäº¤æ˜“
    const tx = await this.buildSolanaTransaction(transaction);
    
    // å‘é€äº¤æ˜“
    const signature = await connection.sendRawTransaction(tx.serialize());
    
    // ç­‰å¾…ç¡®è®¤
    const confirmation = await connection.confirmTransaction(signature);

    return {
      transactionHash: signature,
      blockNumber: confirmation.value?.slot,
      network: network.chainId,
      confirmedAt: Date.now(),
    };
  }

  private async settleSuiPayment(network: any, transaction: any): Promise<any> {
    // Sui é“¾ç»“ç®—é€»è¾‘
    const suiClient = this.chainProvider.getSuiClient(network.chainId);
    
    // æ„å»ºäº¤æ˜“
    const tx = await this.buildSuiTransaction(transaction);
    
    // æ‰§è¡Œäº¤æ˜“
    const result = await suiClient.executeTransactionBlock({
      transactionBlock: tx,
      options: {
        showEffects: true,
        showEvents: true,
      },
    });

    return {
      transactionHash: result.digest,
      blockNumber: result.effects?.executedEpoch,
      network: network.chainId,
      confirmedAt: Date.now(),
      gasUsed: result.effects?.gasUsed?.computationCost,
    };
  }

  private parseAmount(amount: string, decimals: number): string {
    // å°†å­—ç¬¦ä¸²é‡‘é¢è½¬æ¢ä¸ºæœ€å°å•ä½
    const parsed = parseFloat(amount);
    return (parsed * Math.pow(10, decimals)).toString();
  }

  private async buildSolanaTransaction(transaction: any): Promise<any> {
    // Solana äº¤æ˜“æ„å»ºé€»è¾‘
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨ @solana/web3.js
    return {}; // å ä½ç¬¦
  }

  private async buildSuiTransaction(transaction: any): Promise<any> {
    // Sui äº¤æ˜“æ„å»ºé€»è¾‘
    // å®é™…å®ç°éœ€è¦ä½¿ç”¨ @mysten/sui.js
    return {}; // å ä½ç¬¦
  }
}
```

**äº¤ä»˜ç‰©**:
- Facilitator æœåŠ¡
- æ”¯ä»˜éªŒè¯å™¨
- å¤šé“¾ç»“ç®—æœåŠ¡
- API æ¥å£æ–‡æ¡£

#### ç¬¬3å‘¨: å®¢æˆ·ç«¯ SDK å¼€å‘
**ç›®æ ‡**: å¼€å‘å¤šè¯­è¨€å®¢æˆ·ç«¯ SDK

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç° TypeScript/JavaScript SDK
- [ ] å¼€å‘ Python SDK
- [ ] åˆ›å»º Go SDK
- [ ] ç¼–å†™ä½¿ç”¨ç¤ºä¾‹å’Œæ–‡æ¡£

**TypeScript SDK å®ç°**:
```typescript
// X402 å®¢æˆ·ç«¯ SDK
export class X402Client {
  private wallet: any;
  private facilitatorUrl?: string;

  constructor(options: {
    wallet: any; // é’±åŒ…å®ä¾‹
    facilitatorUrl?: string;
  }) {
    this.wallet = options.wallet;
    this.facilitatorUrl = options.facilitatorUrl;
  }

  // å‘é€å¸¦æ”¯ä»˜çš„ HTTP è¯·æ±‚
  async requestWithPayment(
    url: string,
    options: RequestOptions = {}
  ): Promise<PaymentResponse> {
    try {
      // é¦–æ¬¡è¯·æ±‚ï¼Œè·å–æ”¯ä»˜è¦æ±‚
      const initialResponse = await fetch(url, {
        method: options.method || 'GET',
        headers: options.headers,
        body: options.body,
      });

      if (initialResponse.status !== 402) {
        // ä¸éœ€è¦æ”¯ä»˜ï¼Œç›´æ¥è¿”å›
        return {
          status: initialResponse.status,
          headers: Object.fromEntries(initialResponse.headers.entries()),
          data: await initialResponse.text(),
        };
      }

      // è§£ææ”¯ä»˜è¦æ±‚
      const paymentRequired: PaymentRequired = await initialResponse.json();

      // æ„å»ºæ”¯ä»˜è´Ÿè½½
      const paymentPayload = await this.buildPaymentPayload(paymentRequired);

      // é‡è¯•è¯·æ±‚ï¼Œé™„å¸¦æ”¯ä»˜ä¿¡æ¯
      const paymentResponse = await fetch(url, {
        method: options.method || 'GET',
        headers: {
          ...options.headers,
          'X-PAYMENT': Buffer.from(JSON.stringify(paymentPayload)).toString('base64'),
        },
        body: options.body,
      });

      return {
        status: paymentResponse.status,
        headers: Object.fromEntries(paymentResponse.headers.entries()),
        data: await paymentResponse.text(),
      };
    } catch (error) {
      console.error('X402 request error:', error);
      throw error;
    }
  }

  // æ„å»ºæ”¯ä»˜è´Ÿè½½
  private async buildPaymentPayload(
    paymentRequired: PaymentRequired
  ): Promise<PaymentPayload> {
    const { payment, network, scheme } = paymentRequired;

    // ç”Ÿæˆéšæœºæ•°
    const nonce = this.generateNonce();

    // æ„å»ºäº¤æ˜“å¯¹è±¡
    const transaction = {
      amount: payment.amount,
      token: payment.token,
      recipient: payment.recipient,
      sender: await this.wallet.getAddress(),
      nonce,
      deadline: payment.deadline,
    };

    // åˆ›å»ºç­¾åæ¶ˆæ¯
    const message = this.createSignatureMessage(scheme, network, transaction);

    // ç­¾åæ¶ˆæ¯
    const signature = await this.wallet.signMessage(message);

    return {
      scheme,
      network,
      transaction,
      signature: {
        type: this.getSignatureType(),
        data: signature,
        publicKey: await this.wallet.getPublicKey(),
      },
      timestamp: Date.now(),
    };
  }

  // åˆ›å»ºç­¾åæ¶ˆæ¯
  private createSignatureMessage(
    scheme: string,
    network: any,
    transaction: any
  ): string {
    const messageData = {
      scheme,
      network,
      transaction: {
        amount: transaction.amount,
        token: transaction.token,
        recipient: transaction.recipient,
        sender: transaction.sender,
        nonce: transaction.nonce,
        deadline: transaction.deadline,
      },
      timestamp: Date.now(),
    };

    return JSON.stringify(messageData, Object.keys(messageData).sort());
  }

  // ç”Ÿæˆéšæœºæ•°
  private generateNonce(): string {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }

  // è·å–ç­¾åç±»å‹
  private getSignatureType(): 'ecdsa' | 'ed25519' | 'bip322' {
    // æ ¹æ®é’±åŒ…ç±»å‹è¿”å›ç›¸åº”çš„ç­¾åç±»å‹
    return 'ecdsa'; // é»˜è®¤
  }

  // éªŒè¯æ”¯ä»˜ï¼ˆé€šè¿‡ Facilitatorï¼‰
  async verifyPayment(paymentPayload: PaymentPayload): Promise<boolean> {
    if (!this.facilitatorUrl) {
      throw new Error('Facilitator URL not configured');
    }

    try {
      const response = await fetch(`${this.facilitatorUrl}/verify`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(paymentPayload),
      });

      const result = await response.json();
      return result.valid;
    } catch (error) {
      console.error('Payment verification error:', error);
      return false;
    }
  }

  // æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€
  async getPaymentStatus(
    transactionHash: string,
    network: string
  ): Promise<PaymentStatus> {
    if (!this.facilitatorUrl) {
      throw new Error('Facilitator URL not configured');
    }

    try {
      const response = await fetch(
        `${this.facilitatorUrl}/status/${transactionHash}?network=${network}`
      );

      return await response.json();
    } catch (error) {
      console.error('Payment status query error:', error);
      throw error;
    }
  }
}

// ä¾¿æ·å‡½æ•°
export async function fetchWithPayment(
  url: string,
  options: {
    wallet: any;
    facilitatorUrl?: string;
    method?: string;
    headers?: Record<string, string>;
    body?: string;
  }
): Promise<PaymentResponse> {
  const client = new X402Client({
    wallet: options.wallet,
    facilitatorUrl: options.facilitatorUrl,
  });

  return client.requestWithPayment(url, {
    method: options.method,
    headers: options.headers,
    body: options.body,
  });
}

// ç±»å‹å®šä¹‰
export interface PaymentResponse {
  status: number;
  headers: Record<string, string>;
  data: string;
}

export interface PaymentStatus {
  hash: string;
  network: string;
  status: 'pending' | 'confirmed' | 'failed';
  timestamp: number;
}

export interface RequestOptions {
  method?: string;
  headers?: Record<string, string>;
  body?: string;
}

// ä½¿ç”¨ç¤ºä¾‹
export class ExampleUsage {
  async example() {
    // åˆå§‹åŒ–é’±åŒ…ï¼ˆç¤ºä¾‹ä½¿ç”¨ ethers.jsï¼‰
    const wallet = new ethers.Wallet('private_key_here');
    
    // åˆ›å»º X402 å®¢æˆ·ç«¯
    const client = new X402Client({
      wallet,
      facilitatorUrl: 'https://facilitator.x402.org',
    });

    try {
      // å‘é€å¸¦æ”¯ä»˜çš„è¯·æ±‚
      const response = await client.requestWithPayment(
        'https://api.example.com/protected-resource',
        {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      if (response.status === 200) {
        console.log('Payment successful!');
        console.log('Response data:', response.data);
        console.log('Payment info:', response.headers['x-payment-response']);
      }
    } catch (error) {
      console.error('Request failed:', error);
    }
  }
}
```

**Python SDK å®ç°**:
```python
# x402_python_sdk.py
import json
import base64
import hashlib
import time
from typing import Dict, Any, Optional
import requests
from web3 import Web3
from eth_account import Account

class X402Client:
    def __init__(self, 
                 private_key: str,
                 facilitator_url: Optional[str] = None):
        self.account = Account.from_key(private_key)
        self.facilitator_url = facilitator_url

    def request_with_payment(self, 
                           url: str,
                           method: str = 'GET',
                           headers: Optional[Dict[str, str]] = None,
                           body: Optional[str] = None) -> Dict[str, Any]:
        """å‘é€å¸¦æ”¯ä»˜çš„ HTTP è¯·æ±‚"""
        headers = headers or {}
        
        try:
            # é¦–æ¬¡è¯·æ±‚
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                data=body
            )
            
            if response.status_code != 402:
                # ä¸éœ€è¦æ”¯ä»˜
                return {
                    'status': response.status_code,
                    'headers': dict(response.headers),
                    'data': response.text
                }
            
            # è§£ææ”¯ä»˜è¦æ±‚
            payment_required = response.json()
            
            # æ„å»ºæ”¯ä»˜è´Ÿè½½
            payment_payload = self.build_payment_payload(payment_required)
            
            # é‡è¯•è¯·æ±‚ï¼Œé™„å¸¦æ”¯ä»˜ä¿¡æ¯
            payment_headers = headers.copy()
            payment_headers['X-PAYMENT'] = base64.b64encode(
                json.dumps(payment_payload).encode()
            ).decode()
            
            payment_response = requests.request(
                method=method,
                url=url,
                headers=payment_headers,
                data=body
            )
            
            return {
                'status': payment_response.status_code,
                'headers': dict(payment_response.headers),
                'data': payment_response.text
            }
            
        except Exception as e:
            print(f"X402 request error: {e}")
            raise

    def build_payment_payload(self, payment_required: Dict[str, Any]) -> Dict[str, Any]:
        """æ„å»ºæ”¯ä»˜è´Ÿè½½"""
        payment = payment_required['payment']
        network = payment_required['network']
        scheme = payment_required['scheme']
        
        # ç”Ÿæˆéšæœºæ•°
        nonce = self._generate_nonce()
        
        # æ„å»ºäº¤æ˜“å¯¹è±¡
        transaction = {
            'amount': payment['amount'],
            'token': payment['token'],
            'recipient': payment['recipient'],
            'sender': self.account.address,
            'nonce': nonce,
            'deadline': payment.get('deadline')
        }
        
        # åˆ›å»ºç­¾åæ¶ˆæ¯
        message = self._create_signature_message(scheme, network, transaction)
        
        # ç­¾åæ¶ˆæ¯
        signature = self.account.sign_message(message)
        
        return {
            'scheme': scheme,
            'network': network,
            'transaction': transaction,
            'signature': {
                'type': 'ecdsa',
                'data': signature.signature.hex(),
                'publicKey': self.account.key.hex()
            },
            'timestamp': int(time.time() * 1000)
        }

    def _create_signature_message(self, scheme: str, network: Dict[str, Any], transaction: Dict[str, Any]) -> str:
        """åˆ›å»ºç­¾åæ¶ˆæ¯"""
        message_data = {
            'scheme': scheme,
            'network': network,
            'transaction': {
                'amount': transaction['amount'],
                'token': transaction['token'],
                'recipient': transaction['recipient'],
                'sender': transaction['sender'],
                'nonce': transaction['nonce'],
                'deadline': transaction.get('deadline')
            },
            'timestamp': int(time.time() * 1000)
        }
        
        return json.dumps(message_data, sort_keys=True)

    def _generate_nonce(self) -> str:
        """ç”Ÿæˆéšæœºæ•°"""
        return hashlib.sha256(
            f"{time.time()}{self.account.address}".encode()
        ).hexdigest()[:16]

    def verify_payment(self, payment_payload: Dict[str, Any]) -> bool:
        """é€šè¿‡ Facilitator éªŒè¯æ”¯ä»˜"""
        if not self.facilitator_url:
            raise ValueError("Facilitator URL not configured")
        
        try:
            response = requests.post(
                f"{self.facilitator_url}/verify",
                json=payment_payload
            )
            
            result = response.json()
            return result.get('valid', False)
            
        except Exception as e:
            print(f"Payment verification error: {e}")
            return False

    def get_payment_status(self, transaction_hash: str, network: str) -> Dict[str, Any]:
        """æŸ¥è¯¢æ”¯ä»˜çŠ¶æ€"""
        if not self.facilitator_url:
            raise ValueError("Facilitator URL not configured")
        
        try:
            response = requests.get(
                f"{self.facilitatorUrl}/status/{transaction_hash}",
                params={'network': network}
            )
            
            return response.json()
            
        except Exception as e:
            print(f"Payment status query error: {e}")
            raise


# ä½¿ç”¨ç¤ºä¾‹
def example_usage():
    # åˆå§‹åŒ–å®¢æˆ·ç«¯
    client = X402Client(
        private_key='your_private_key_here',
        facilitator_url='https://facilitator.x402.org'
    )
    
    try:
        # å‘é€å¸¦æ”¯ä»˜çš„è¯·æ±‚
        response = client.request_with_payment(
            'https://api.example.com/protected-resource',
            method='GET',
            headers={'Content-Type': 'application/json'}
        )
        
        if response['status'] == 200:
            print("Payment successful!")
            print(f"Response data: {response['data']}")
            print(f"Payment info: {response['headers'].get('x-payment-response')}")
            
    except Exception as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    example_usage()
```

**äº¤ä»˜ç‰©**:
- TypeScript/JavaScript SDK
- Python SDK
- Go SDK
- ä½¿ç”¨ç¤ºä¾‹å’Œæ–‡æ¡£

#### ç¬¬4å‘¨: æµ‹è¯•å’ŒéªŒè¯ä½“ç³»
**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„æµ‹è¯•å’ŒéªŒè¯ä½“ç³»

**ä»»åŠ¡æ¸…å•**:
- [ ] å¼€å‘å•å…ƒæµ‹è¯•å¥—ä»¶
- [ ] å®ç°é›†æˆæµ‹è¯•
- [ ] åˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯•
- [ ] å»ºç«‹æ€§èƒ½æµ‹è¯•

**æµ‹è¯•æ¡†æ¶å®ç°**:
```typescript
// X402 æµ‹è¯•å¥—ä»¶
import { X402Client } from '../src/client';
import { X402Middleware } from '../src/middleware';
import { FacilitatorServer } from '../src/facilitator';
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';

describe('X402 Protocol Tests', () => {
  let facilitatorServer: FacilitatorServer;
  let middleware: X402Middleware;
  let client: X402Client;

  beforeEach(async () => {
    // å¯åŠ¨ Facilitator æœåŠ¡å™¨
    facilitatorServer = new FacilitatorServer();
    facilitatorServer.start(3001);

    // é…ç½®ä¸­é—´ä»¶
    middleware = new X402Middleware({
      paymentRequired: {
        scheme: 'x402-v1',
        network: {
          chainId: '1',
          name: 'Ethereum',
          type: 'evm',
        },
        payment: {
          amount: '0.01',
          token: {
            address: '0xA0b86a33E6441E6C7D3E4E8C8B8B8B8B8B8B8B8B',
            symbol: 'USDC',
            decimals: 6,
          },
          recipient: '0x1234567890123456789012345678901234567890',
        },
        facilitator: {
          verifyUrl: 'http://localhost:3001/verify',
          settleUrl: 'http://localhost:3001/settle',
        },
      },
      validateLocally: false,
    });

    // åˆå§‹åŒ–å®¢æˆ·ç«¯
    client = new X402Client({
      wallet: new MockWallet(),
      facilitatorUrl: 'http://localhost:3001',
    });
  });

  afterEach(async () => {
    // æ¸…ç†èµ„æº
    if (facilitatorServer) {
      // å…³é—­æœåŠ¡å™¨
    }
  });

  describe('Payment Flow', () => {
    it('should handle complete payment flow', async () => {
      // æ¨¡æ‹Ÿèµ„æºæœåŠ¡å™¨
      const app = express();
      app.use('/protected', middleware.middleware());
      app.get('/protected', (req, res) => {
        res.json({ message: 'Access granted!', data: 'Protected content' });
      });

      const server = app.listen(3002);

      try {
        // æ‰§è¡Œæ”¯ä»˜æµç¨‹
        const response = await client.requestWithPayment(
          'http://localhost:3002/protected'
        );

        // éªŒè¯ç»“æœ
        expect(response.status).toBe(200);
        expect(response.data).toContain('Access granted');
        
        const paymentResponse = JSON.parse(
          response.headers['x-payment-response'] || '{}'
        );
        expect(paymentResponse.transactionHash).toBeDefined();
      } finally {
        server.close();
      }
    });

    it('should reject invalid payment', async () => {
      // åˆ›å»ºæ— æ•ˆçš„å®¢æˆ·ç«¯
      const invalidClient = new X402Client({
        wallet: new InvalidWallet(),
        facilitatorUrl: 'http://localhost:3001',
      });

      const app = express();
      app.use('/protected', middleware.middleware());
      app.get('/protected', (req, res) => {
        res.json({ message: 'Access granted!' });
      });

      const server = app.listen(3003);

      try {
        const response = await invalidClient.requestWithPayment(
          'http://localhost:3003/protected'
        );

        // åº”è¯¥è¿”å› 402 çŠ¶æ€ç 
        expect(response.status).toBe(402);
      } finally {
        server.close();
      }
    });
  });

  describe('Facilitator Tests', () => {
    it('should verify valid payment', async () => {
      const paymentPayload = await client.buildPaymentPayload({
        scheme: 'x402-v1',
        network: {
          chainId: '1',
          type: 'evm',
        },
        payment: {
          amount: '0.01',
          token: {
            address: '0xA0b86a33E6441E6C7D3E4E8C8B8B8B8B8B8B8B8B',
            symbol: 'USDC',
            decimals: 6,
          },
          recipient: '0x1234567890123456789012345678901234567890',
        },
      });

      const response = await fetch('http://localhost:3001/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(paymentPayload),
      });

      const result = await response.json();
      expect(result.valid).toBe(true);
    });

    it('should reject invalid payment format', async () => {
      const invalidPayload = {
        scheme: 'x402-v1',
        // ç¼ºå°‘å¿…è¦å­—æ®µ
      };

      const response = await fetch('http://localhost:3001/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(invalidPayload),
      });

      const result = await response.json();
      expect(result.valid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Performance Tests', () => {
    it('should handle concurrent requests', async () => {
      const concurrentRequests = 100;
      const requests = [];

      for (let i = 0; i < concurrentRequests; i++) {
        requests.push(
          client.requestWithPayment('http://localhost:3002/protected')
        );
      }

      const startTime = Date.now();
      const results = await Promise.allSettled(requests);
      const endTime = Date.now();

      const successfulRequests = results.filter(
        result => result.status === 'fulfilled'
      ).length;

      expect(successfulRequests).toBeGreaterThan(80); // è‡³å°‘ 80% æˆåŠŸ
      expect(endTime - startTime).toBeLessThan(10000); // 10ç§’å†…å®Œæˆ
    });
  });
});

// Mock é’±åŒ…å®ç°
class MockWallet {
  async getAddress(): Promise<string> {
    return '0x1234567890123456789012345678901234567890';
  }

  async getPublicKey(): Promise<string> {
    return '0xpublickey';
  }

  async signMessage(message: string): Promise<string> {
    // è¿”å›æ¨¡æ‹Ÿç­¾å
    return '0xsignedmessage';
  }
}

class InvalidWallet {
  async getAddress(): Promise<string> {
    return '0xinvalidaddress';
  }

  async getPublicKey(): Promise<string> {
    return '0xinvalidpublickey';
  }

  async signMessage(message: string): Promise<string> {
    // è¿”å›æ— æ•ˆç­¾å
    return '0xinvalidsignature';
  }
}
```

**äº¤ä»˜ç‰©**:
- å®Œæ•´æµ‹è¯•å¥—ä»¶
- æ€§èƒ½æµ‹è¯•æ¡†æ¶
- é›†æˆæµ‹è¯•ç¯å¢ƒ
- æµ‹è¯•æ–‡æ¡£å’ŒæŠ¥å‘Š

### é˜¶æ®µ 2: é«˜çº§åŠŸèƒ½å¼€å‘ (ç¬¬5-8å‘¨)

#### ç¬¬5å‘¨: å¤šé“¾æ”¯æŒæ‰©å±•
**ç›®æ ‡**: æ‰©å±•å¯¹æ›´å¤šåŒºå—é“¾ç½‘ç»œçš„æ”¯æŒ

**ä»»åŠ¡æ¸…å•**:
- [ ] é›†æˆ Solana æ”¯æŒ
- [ ] æ·»åŠ  Sui åŒºå—é“¾æ”¯æŒ
- [ ] å®ç°è·¨é“¾æ”¯ä»˜è·¯ç”±
- [ ] å¼€å‘ç½‘ç»œæŠ½è±¡å±‚

#### ç¬¬6å‘¨: é«˜çº§æ”¯ä»˜åŠŸèƒ½
**ç›®æ ‡**: å®ç°é«˜çº§æ”¯ä»˜ç‰¹æ€§

**ä»»åŠ¡æ¸…å•**:
- [ ] å¼€å‘è®¢é˜…æ”¯ä»˜
- [ ] å®ç°åˆ†æœŸä»˜æ¬¾
- [ ] æ·»åŠ æ”¯ä»˜æ¡ä»¶é€»è¾‘
- [ ] åˆ›å»ºæ”¯ä»˜æ¨¡æ¿ç³»ç»Ÿ

#### ç¬¬7å‘¨: AI Agent é›†æˆ
**ç›®æ ‡**: ä¸“é—¨ä¸º AI Agents ä¼˜åŒ–æ”¯ä»˜ä½“éªŒ

**ä»»åŠ¡æ¸…å•**:
- [ ] å¼€å‘ AI Agent SDK
- [ ] å®ç°è‡ªåŠ¨æ”¯ä»˜é€»è¾‘
- [ ] æ·»åŠ é¢„ç®—ç®¡ç†
- [ ] åˆ›å»ºæ”¯ä»˜ç­–ç•¥å¼•æ“

#### ç¬¬8å‘¨: ç”Ÿæ€ç³»ç»Ÿå»ºè®¾
**ç›®æ ‡**: æ„å»ºå®Œæ•´çš„å¼€å‘è€…ç”Ÿæ€

**ä»»åŠ¡æ¸…å•**:
- [ ] å¼€å‘å¼€å‘è€…å·¥å…·
- [ ] åˆ›å»ºæ–‡æ¡£ç½‘ç«™
- [ ] å»ºç«‹ç¤ºä¾‹é¡¹ç›®åº“
- [ ] å¯åŠ¨ç¤¾åŒºè®¡åˆ’

### é˜¶æ®µ 3: ç”Ÿäº§çº§ä¼˜åŒ– (ç¬¬9-12å‘¨)

#### ç¬¬9å‘¨: æ€§èƒ½ä¼˜åŒ–
**ç›®æ ‡**: ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½å’Œå¯æ‰©å±•æ€§

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°ç¼“å­˜æœºåˆ¶
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢
- [ ] æ·»åŠ è´Ÿè½½å‡è¡¡
- [ ] å®ç°æ°´å¹³æ‰©å±•

#### ç¬¬10å‘¨: å®‰å…¨åŠ å›º
**ç›®æ ‡**: å¢å¼ºç³»ç»Ÿå®‰å…¨æ€§

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°é€Ÿç‡é™åˆ¶
- [ ] æ·»åŠ é˜²é‡æ”¾æ”»å‡»
- [ ] åŠ å¼ºè¾“å…¥éªŒè¯
- [ ] å®ç°å®‰å…¨ç›‘æ§

#### ç¬¬11å‘¨: ç›‘æ§å’Œåˆ†æ
**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„ç›‘æ§ä½“ç³»

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°å®æ—¶ç›‘æ§
- [ ] å¼€å‘åˆ†æä»ªè¡¨æ¿
- [ ] æ·»åŠ å‘Šè­¦ç³»ç»Ÿ
- [ ] åˆ›å»ºæŠ¥å‘Šç³»ç»Ÿ

#### ç¬¬12å‘¨: ç”Ÿäº§éƒ¨ç½²
**ç›®æ ‡**: éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ

**ä»»åŠ¡æ¸…å•**:
- [ ] éƒ¨ç½²ç”Ÿäº§ç¯å¢ƒ
- [ ] è¿›è¡Œå‹åŠ›æµ‹è¯•
- [ ] å»ºç«‹è¿ç»´æµç¨‹
- [ ] å®Œå–„æ–‡æ¡£

## ğŸ”§ å¼€å‘å·¥å…·å’Œæµç¨‹

### å¼€å‘ç¯å¢ƒ

**å¿…éœ€å·¥å…·**:
```bash
# Node.js å¼€å‘ç¯å¢ƒ
nvm install 18
nvm use 18

# Python å¼€å‘ç¯å¢ƒ
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# Go å¼€å‘ç¯å¢ƒ
go version

# ä¾èµ–å®‰è£…
npm install
pip install -r requirements.txt
go mod tidy
```

### å¼€å‘æµç¨‹

**Git å·¥ä½œæµ**:
```bash
# åŠŸèƒ½å¼€å‘
git checkout -b feature/x402-core
git add .
git commit -m "feat: implement X402 core protocol"
git push origin feature/x402-core

# ä»£ç å®¡æŸ¥ååˆå¹¶
git checkout main
git merge feature/x402-core
git tag v1.0.0
git push origin main --tags
```

**CI/CD æµç¨‹**:
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x]
        python-version: [3.9, 3.10, 3.11]
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          npm ci
          pip install -r requirements.txt
      
      - name: Run tests
        run: |
          npm test
          python -m pytest
      
      - name: Build
        run: |
          npm run build
          python setup.py build
```

## ğŸ“Š è´¨é‡ä¿è¯

### æµ‹è¯•ç­–ç•¥

**æµ‹è¯•é‡‘å­—å¡”**:
- **å•å…ƒæµ‹è¯•**: 70% - æµ‹è¯•å•ä¸ªå‡½æ•°å’Œç±»
- **é›†æˆæµ‹è¯•**: 20% - æµ‹è¯•ç»„ä»¶é—´äº¤äº’
- **ç«¯åˆ°ç«¯æµ‹è¯•**: 10% - æµ‹è¯•å®Œæ•´ç”¨æˆ·æµç¨‹

**æµ‹è¯•è¦†ç›–ç‡è¦æ±‚**:
- æ ¸å¿ƒåè®®ä»£ç : > 95%
- SDK ä»£ç : > 90%
- å·¥å…·ä»£ç : > 85%

### å®‰å…¨æ£€æŸ¥

**å®‰å…¨å®¡è®¡æ¸…å•**:
- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç†
- [ ] ç­¾åéªŒè¯é€»è¾‘
- [ ] é‡æ”¾æ”»å‡»é˜²æŠ¤
- [ ] é€Ÿç‡é™åˆ¶
- [ ] é”™è¯¯å¤„ç†å’Œä¿¡æ¯æ³„éœ²
- [ ] ä¾èµ–åŒ…å®‰å…¨æ‰«æ

**ä»£ç è´¨é‡å·¥å…·**:
```json
{
  "scripts": {
    "lint": "eslint src --ext .ts,.js",
    "format": "prettier --write src",
    "audit": "npm audit",
    "test": "jest --coverage",
    "test:security": "npm run audit && npm run lint"
  }
}
```

## ğŸš€ éƒ¨ç½²å’Œè¿ç»´

### éƒ¨ç½²æ¶æ„

**ç”Ÿäº§ç¯å¢ƒæ¶æ„**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Load Balancer â”‚    â”‚   API Gateway   â”‚    â”‚   Facilitator   â”‚
â”‚   (è´Ÿè½½å‡è¡¡)     â”‚â—„â”€â”€â–ºâ”‚   (API ç½‘å…³)     â”‚â—„â”€â”€â–ºâ”‚   Cluster       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Monitoring    â”‚
                    â”‚   (ç›‘æ§å‘Šè­¦)     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç›‘æ§æŒ‡æ ‡

**å…³é”®æŒ‡æ ‡**:
```typescript
// ç›‘æ§æŒ‡æ ‡å®šä¹‰
const metrics = {
  // ä¸šåŠ¡æŒ‡æ ‡
  paymentRequests: 'counter',
  successfulPayments: 'counter',
  failedPayments: 'counter',
  averagePaymentAmount: 'histogram',
  
  // æŠ€æœ¯æŒ‡æ ‡
  requestLatency: 'histogram',
  errorRate: 'gauge',
  activeConnections: 'gauge',
  memoryUsage: 'gauge',
  
  // åŒºå—é“¾æŒ‡æ ‡
  transactionConfirmations: 'counter',
  averageConfirmationTime: 'histogram',
  gasUsage: 'histogram',
};
```

### å‘Šè­¦è§„åˆ™

**å‘Šè­¦é…ç½®**:
```yaml
# prometheus.yml
groups:
  - name: x402_alerts
    rules:
      - alert: HighErrorRate
        expr: error_rate > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          
      - alert: SlowPaymentProcessing
        expr: average_payment_latency > 30000
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Payment processing is slow"
```

## ğŸ“ˆ æˆåŠŸæŒ‡æ ‡

### æŠ€æœ¯æŒ‡æ ‡

**æ€§èƒ½æŒ‡æ ‡**:
- API å“åº”æ—¶é—´ < 100ms (P95)
- æ”¯ä»˜å¤„ç†æ—¶é—´ < 30ç§’
- ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%
- å¹¶å‘å¤„ç†èƒ½åŠ› > 1000 RPS

**è´¨é‡æŒ‡æ ‡**:
- ä»£ç è¦†ç›–ç‡ > 90%
- å®‰å…¨æ¼æ´ = 0
- å¹³å‡æ•…éšœæ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ
- éƒ¨ç½²æˆåŠŸç‡ > 99%

### ä¸šåŠ¡æŒ‡æ ‡

**é‡‡ç”¨æŒ‡æ ‡**:
- æœˆæ´»è·ƒå¼€å‘è€…æ•°é‡
- API è°ƒç”¨æ¬¡æ•°
- é›†æˆé¡¹ç›®æ•°é‡
- ç¤¾åŒºè´¡çŒ®è€…æ•°é‡

**ç”Ÿæ€æŒ‡æ ‡**:
- æ”¯æŒçš„åŒºå—é“¾æ•°é‡
- é›†æˆçš„é’±åŒ…æ•°é‡
- Facilitator å®ä¾‹æ•°é‡
- æ–‡æ¡£è®¿é—®é‡

## ğŸ¯ é£é™©ç®¡ç†

### æŠ€æœ¯é£é™©

**åŒºå—é“¾é£é™©**:
- ç½‘ç»œæ‹¥å µå’Œå»¶è¿Ÿ
- Gas è´¹ç”¨æ³¢åŠ¨
- äº¤æ˜“å¤±è´¥å’Œå›æ»š
- æ™ºèƒ½åˆçº¦æ¼æ´

**ç¼“è§£æªæ–½**:
- å¤šé“¾æ”¯æŒå’Œè·¯ç”±
- Gas è´¹ç”¨é¢„ä¼°å’Œä¼˜åŒ–
- äº¤æ˜“é‡è¯•æœºåˆ¶
- ä¸¥æ ¼çš„å®‰å…¨å®¡è®¡

### ä¸šåŠ¡é£é™©

**ç«äº‰é£é™©**:
- ç±»ä¼¼åè®®å‡ºç°
- æŠ€æœ¯æ ‡å‡†ç«äº‰
- ç”Ÿæ€ç³»ç»Ÿç¢ç‰‡åŒ–

**åº”å¯¹ç­–ç•¥**:
- æŒç»­æŠ€æœ¯åˆ›æ–°
- æ ‡å‡†åŒ–å‚ä¸
- å¼€æºç¤¾åŒºå»ºè®¾

## ğŸ“š å­¦ä¹ å’Œæˆé•¿

### æŠ€æœ¯åŸ¹è®­

**å›¢é˜ŸæŠ€èƒ½æå‡**:
- åŒºå—é“¾æŠ€æœ¯æ·±åº¦åŸ¹è®­
- æ”¯ä»˜åè®®è®¾è®¡åŸç†
- å¤šé“¾å¼€å‘å®è·µ
- å®‰å…¨æœ€ä½³å®è·µ

**çŸ¥è¯†åˆ†äº«**:
- æ¯å‘¨æŠ€æœ¯åˆ†äº«ä¼š
- ä»£ç å®¡æŸ¥ä¼šè®®
- é¡¹ç›®å¤ç›˜æ€»ç»“
- å¤–éƒ¨æŠ€æœ¯äº¤æµ

### ç¤¾åŒºå»ºè®¾

**å¼€å‘è€…ç”Ÿæ€**:
- å¼€æºé¡¹ç›®ç»´æŠ¤
- æŠ€æœ¯åšå®¢å†™ä½œ
- ä¼šè®®æ¼”è®²å‚ä¸
- åœ¨çº¿è¯¾ç¨‹å¼€å‘

**ç”¨æˆ·ç¤¾åŒº**:
- ç”¨æˆ·åé¦ˆæ”¶é›†
- äº§å“ä½¿ç”¨æ•™ç¨‹
- ç¤¾åŒºæ´»åŠ¨ç»„ç»‡
- å®¢æˆ·æ”¯æŒä½“ç³»

---

## ğŸ“ è”ç³»å’Œæ”¯æŒ

**é¡¹ç›®å›¢é˜Ÿ**:
- æŠ€æœ¯è´Ÿè´£äºº: [è”ç³»æ–¹å¼]
- äº§å“è´Ÿè´£äºº: [è”ç³»æ–¹å¼]
- ç¤¾åŒºè´Ÿè´£äºº: [è”ç³»æ–¹å¼]

**ç¤¾åŒºæ”¯æŒ**:
- Discord ç¤¾åŒº: [é“¾æ¥]
- Telegram ç¾¤ç»„: [é“¾æ¥]
- GitHub Issues: [é“¾æ¥]
- æŠ€æœ¯æ–‡æ¡£: [é“¾æ¥]

**ç´§æ€¥è”ç³»**:
- å®‰å…¨æ¼æ´æŠ¥å‘Š: security@x402.org
- æŠ€æœ¯æ”¯æŒ: support@x402.org
- å•†åŠ¡åˆä½œ: business@x402.org

---

**X402 åè®®å°†é‡æ–°å®šä¹‰ Web åŸç”Ÿæ”¯ä»˜ï¼Œè®©åŠ å¯†è´§å¸æ”¯ä»˜åƒ HTTP ä¸€æ ·ç®€å•è‡ªç„¶ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ„å»ºä¸‹ä¸€ä»£äº’è”ç½‘æ”¯ä»˜åŸºç¡€è®¾æ–½ï¼** ğŸŒğŸ’¸ğŸš€
